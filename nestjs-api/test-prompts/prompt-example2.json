{
  "prompt": "Please analyze this Node.js code:\n\nconst express = require('express');\nconst mysql = require('mysql');\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst app = express();\nconst port = 3000;\n\n// ConexÃ£o global ao banco de dados (anti-pattern)\nconst connection = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: 'senha123', // ðŸ”´ Senha hardcoded\n    database: 'loja'\n});\n\n// VariÃ¡veis globais para cache (anti-pattern)\nlet usuariosCache = [];\nlet produtosCache = [];\n\n// Middleware inseguro que expÃµe informaÃ§Ãµes sensÃ­veis\napp.use((req, res, next) => {\n    console.log('Request Headers:', req.headers); // ðŸ”´ Log de informaÃ§Ãµes sensÃ­veis\n    console.log('Request Body:', req.body);\n    next();\n});\n\n// FunÃ§Ã£o de autenticaÃ§Ã£o mal implementada\nfunction autenticar(req, res, next) {\n    const token = req.headers['x-auth'];\n    if (token === 'senha-super-secreta') { // ðŸ”´ Token hardcoded\n        next();\n    } else {\n        res.status(401).send('NÃ£o autorizado');\n    }\n}\n\n// Classe que mistura responsabilidades (violaÃ§Ã£o do SRP)\nclass GerenciadorDeTudo {\n    constructor() {\n        this.pedidos = [];\n        this.emails = [];\n        this.pagamentos = [];\n    }\n\n    // MÃ©todo com muitas responsabilidades\n    async processarPedido(pedido) {\n        // ðŸ”´ SQL injection vulnerÃ¡vel\n        const query = `INSERT INTO pedidos VALUES (${pedido.id}, '${pedido.cliente}')`;\n        \n        connection.query(query, async (err, result) => {\n            if (err) {\n                console.error(err); // ðŸ”´ Log de erro inadequado\n                return;\n            }\n\n            // ðŸ”´ Callback hell\n            this.enviarEmail(pedido, (emailErr) => {\n                if (emailErr) {\n                    console.error(emailErr);\n                    return;\n                }\n\n                this.processarPagamento(pedido, (pagErr) => {\n                    if (pagErr) {\n                        console.error(pagErr);\n                        return;\n                    }\n\n                    this.atualizarEstoque(pedido, (estErr) => {\n                        if (estErr) {\n                            console.error(estErr);\n                            return;\n                        }\n                    });\n                });\n            });\n        });\n    }\n\n    // MÃ©todos que deveriam estar em classes separadas\n    async enviarEmail(pedido, callback) {\n        setTimeout(() => {\n            console.log(`Email enviado para ${pedido.cliente}`);\n            callback(null);\n        }, 1000);\n    }\n\n    async processarPagamento(pedido, callback) {\n        // ðŸ”´ InformaÃ§Ãµes sensÃ­veis em logs\n        console.log(`Processando pagamento: ${pedido.cartao}`);\n        callback(null);\n    }\n\n    async atualizarEstoque(pedido, callback) {\n        // ðŸ”´ Loop ineficiente\n        for (let i = 0; i < 1000000; i++) {\n            if (i === pedido.id) {\n                // Fazer algo\n            }\n        }\n        callback(null);\n    }\n}\n\n// Endpoints mal implementados\napp.get('/usuarios', (req, res) => {\n    // ðŸ”´ Retorno de senha no response\n    connection.query('SELECT id, nome, email, senha FROM usuarios', (err, results) => {\n        if (err) throw err; // ðŸ”´ Erro exposto diretamente\n        res.json(results);\n    });\n});\n\napp.post('/usuarios', express.json(), (req, res) => {\n    const { nome, email, senha } = req.body;\n    // ðŸ”´ Senha em texto plano\n    const query = `INSERT INTO usuarios (nome, email, senha) VALUES ('${nome}', '${email}', '${senha}')`;\n    \n    connection.query(query, (err, result) => {\n        if (err) {\n            console.error(err);\n            res.status(500).send('Erro interno');\n            return;\n        }\n        res.send('UsuÃ¡rio criado!');\n    });\n});\n\n// Endpoint com operaÃ§Ã£o sÃ­ncrona bloqueante\napp.get('/arquivos', (req, res) => {\n    // ðŸ”´ OperaÃ§Ã£o sÃ­ncrona bloqueante\n    const files = fs.readdirSync('./uploads');\n    res.json(files);\n});\n\n// FunÃ§Ã£o com memory leak\nfunction cacheManager() {\n    setInterval(() => {\n        // ðŸ”´ Memory leak - array cresce indefinidamente\n        usuariosCache.push({ timestamp: Date.now() });\n    }, 1000);\n}\n\n// Evento nÃ£o tratado\nprocess.on('uncaughtException', (err) => {\n    // ðŸ”´ Apenas log, sem tratamento adequado\n    console.error('Erro nÃ£o tratado:', err);\n});\n\nconst gerenciador = new GerenciadorDeTudo();\n\napp.listen(port, () => {\n    console.log(`Servidor rodando em http://localhost:${port}`);\n    cacheManager(); // Inicia o memory leak\n});"
}